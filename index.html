import React, { useState, useEffect, useRef } from 'react';

const ImprovedStencilCreator = () => {
  const [image, setImage] = useState(null);
  const [lineThickness, setLineThickness] = useState(1);
  const [edgeStrength, setEdgeStrength] = useState(50);
  const [detail, setDetail] = useState(50);
  const originalCanvasRef = useRef(null);
  const processedCanvasRef = useRef(null);

  useEffect(() => {
    if (image) {
      const img = new Image();
      img.onload = () => {
        drawOriginalImage(img);
        processStencilImage(img);
      };
      img.src = URL.createObjectURL(image);
    }
  }, [image, lineThickness, edgeStrength, detail]);

  const drawOriginalImage = (img) => {
    const canvas = originalCanvasRef.current;
    const ctx = canvas.getContext('2d');
    canvas.width = img.width;
    canvas.height = img.height;
    ctx.drawImage(img, 0, 0);
  };

  const processStencilImage = (img) => {
    const canvas = processedCanvasRef.current;
    const ctx = canvas.getContext('2d');
    canvas.width = img.width;
    canvas.height = img.height;

    // Dibuja la imagen original
    ctx.drawImage(img, 0, 0);

    // Obtiene los datos de la imagen
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;

    // Convierte a escala de grises y aplica contraste
    for (let i = 0; i < data.length; i += 4) {
      const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
      const adjustedAvg = adjustContrast(avg, 50);
      data[i] = data[i + 1] = data[i + 2] = adjustedAvg;
    }

    // Aplica detección de bordes mejorada
    const edgeData = improvedEdgeDetection(imageData, edgeStrength, detail);

    // Limpia el canvas para el resultado final
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = 'white';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Dibuja las líneas del stencil
    ctx.strokeStyle = 'black';
    ctx.lineWidth = lineThickness;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    for (let y = 1; y < canvas.height - 1; y++) {
      for (let x = 1; x < canvas.width - 1; x++) {
        const idx = (y * canvas.width + x) * 4;
        if (edgeData[idx] > 0) {
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x + 1, y);
          ctx.stroke();
        }
      }
    }

    // Aplica suavizado a las líneas
    smoothLines(ctx, canvas.width, canvas.height);
  };

  const adjustContrast = (value, contrast) => {
    return Math.min(255, Math.max(0, (value - 128) * (1 + contrast / 100) + 128));
  };

  const improvedEdgeDetection = (imageData, strength, detail) => {
    const { width, height, data } = imageData;
    const output = new Uint8ClampedArray(data.length);
    const threshold = 255 - (strength * 2.55);
    const detailFactor = detail / 50;

    for (let y = 1; y < height - 1; y++) {
      for (let x = 1; x < width - 1; x++) {
        const idx = (y * width + x) * 4;
        
        // Operador Sobel mejorado
        const gx = 
          -data[idx - 4 - width * 4] + data[idx + 4 - width * 4] +
          -2 * data[idx - 4] + 2 * data[idx + 4] +
          -data[idx - 4 + width * 4] + data[idx + 4 + width * 4];
        const gy = 
          -data[idx - width * 4 - 4] - 2 * data[idx - width * 4] - data[idx - width * 4 + 4] +
          data[idx + width * 4 - 4] + 2 * data[idx + width * 4] + data[idx + width * 4 + 4];

        const edge = Math.sqrt(gx * gx + gy * gy) * detailFactor;
        output[idx] = output[idx + 1] = output[idx + 2] = edge > threshold ? 255 : 0;
        output[idx + 3] = 255;
      }
    }

    return output;
  };

  const smoothLines = (ctx, width, height) => {
    const imageData = ctx.getImageData(0, 0, width, height);
    const data = imageData.data;
    
    for (let y = 1; y < height - 1; y++) {
      for (let x = 1; x < width - 1; x++) {
        const idx = (y * width + x) * 4;
        const neighbors = [
          data[idx - 4], data[idx + 4],
          data[idx - width * 4], data[idx + width * 4],
          data[idx - 4 - width * 4], data[idx + 4 - width * 4],
          data[idx - 4 + width * 4], data[idx + 4 + width * 4]
        ];
        const blackNeighbors = neighbors.filter(n => n === 0).length;
        if (blackNeighbors >= 5) {
          data[idx] = data[idx + 1] = data[idx + 2] = 0;
        }
      }
    }
    
    ctx.putImageData(imageData, 0, 0);
  };

  const handleFileUpload = (e) => {
    if (e.target.files && e.target.files[0]) {
      setImage(e.target.files[0]);
    }
  };

  const downloadStencil = () => {
    const canvas = processedCanvasRef.current;
    const link = document.createElement('a');
    link.download = 'improved_stencil.png';
    link.href = canvas.toDataURL();
    link.click();
  };

  return (
    <div className="flex flex-col items-center p-4 bg-gray-100 min-h-screen">
      <h1 className="text-3xl font-bold mb-6">Creador de Stencils Mejorado</h1>
      
      <div className="w-full max-w-4xl bg-white p-6 rounded-lg shadow-md">
        <input 
          type="file" 
          accept="image/*" 
          onChange={handleFileUpload} 
          className="mb-4"
        />

        {image && (
          <>
            <div className="mb-4">
              <label className="block mb-2">Grosor de Línea: {lineThickness}</label>
              <input 
                type="range" 
                min="0.5" 
                max="3" 
                step="0.1"
                value={lineThickness} 
                onChange={(e) => setLineThickness(Number(e.target.value))} 
                className="w-full"
              />
            </div>

            <div className="mb-4">
              <label className="block mb-2">Fuerza de Bordes: {edgeStrength}</label>
              <input 
                type="range" 
                min="0" 
                max="100" 
                value={edgeStrength} 
                onChange={(e) => setEdgeStrength(Number(e.target.value))} 
                className="w-full"
              />
            </div>

            <div className="mb-4">
              <label className="block mb-2">Nivel de Detalle: {detail}</label>
              <input 
                type="range" 
                min="0" 
                max="100" 
                value={detail} 
                onChange={(e) => setDetail(Number(e.target.value))} 
                className="w-full"
              />
            </div>

            <div className="flex flex-col md:flex-row">
              <div className="md:w-1/2 pr-2">
                <h2 className="text-xl font-semibold mb-2">Imagen Original</h2>
                <canvas ref={originalCanvasRef} className="w-full border" />
              </div>
              <div className="md:w-1/2 pl-2">
                <h2 className="text-xl font-semibold mb-2">Stencil Procesado</h2>
                <canvas ref={processedCanvasRef} className="w-full border" />
              </div>
            </div>

            <button 
              onClick={downloadStencil} 
              className="w-full mt-4 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
            >
              Descargar Stencil
            </button>
          </>
        )}
      </div>
    </div>
  );
};

export default ImprovedStencilCreator;
